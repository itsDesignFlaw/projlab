package VeryGoodViroGame.Field;//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Untitled
//  @ File Name : VeryGoodViroGame.Field.Map.java
//  @ Date : 2022. 03. 27.
//  @ Author : 
//
//


import VeryGoodViroGame.Agent.GeneticCode;
import VeryGoodViroGame.ConsoleIO;
import VeryGoodViroGame.EntityManager;
import VeryGoodViroGame.Virologist;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.geom.Point2D;
import java.io.*;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;

/**
 * Az osztály felelős a játéktér létrehozásáért, és annak kezeléséért.
 */
public class Map
{
    List<Field> fields = new ArrayList<>();
    List<FieldLab> field_labs = new ArrayList<>();
    
    //mapgenbol kopi
    static String name = "default";
    static int maxfields = 0;
    static long useSeed;
    
    static HashMap<String, Integer> placed_fields = new HashMap<String, Integer>();
    static HashMap<String, Integer> place_these = new HashMap<String, Integer>();

    static boolean VerboseLog = false;

    static void printnn(String msg)
    {
        if (VerboseLog)
            System.out.print(msg);
    }
    
    static void printas(String msg)
    {

        if (VerboseLog)
            System.out.println("[MAPGEN] " + msg);
    }
    
    
    static int[][] NoiseMap()
    {
        int sd = maxfields-1;
        int[][] map = new int[sd][sd];
        Random rand = new Random();
        rand.setSeed(useSeed);
        
        for(int x = 0; x < sd; x++)
        {
            for(int y = 0; y < sd; y++)
            {
                map[x][y] = rand.nextInt(10000);
            }
        }
        
        return map;
    }
    
    static int GetPlaceableLeft()
    {
        int ret = 0;
        for(java.util.Map.Entry<String, Integer> v : place_these.entrySet())
        {
            ret += v.getValue();
        }
        return ret;
    }
    
    static String GetRandomPlaceable()
    {
        int total = GetPlaceableLeft();
        String[] selector = new String[total];
        int cc = 0;
        for(java.util.Map.Entry<String, Integer> v : place_these.entrySet())
        {
            for(int i = 0; i < v.getValue(); i++)
            {
                selector[cc] = v.getKey();
                cc++;
            }
        }
        Random rand = new Random();
        rand.setSeed(useSeed);
        return selector[rand.nextInt(total)];
    }
    
    static void placeSomething(int x, int y, String[][] nodemap)
    {
        String place = GetRandomPlaceable();
        nodemap[x][y] = place;
        place_these.put(place, place_these.get(place) - 1);
    }
    
    static String[][] NameFields(String[][] nodemap)
    {
        Random rand = new Random();
        rand.setSeed(useSeed);
        int sd = maxfields-1;
        int remainingSpots = maxfields;
        int inspectedFieldCount = 0;
        
        for(int x = 0; x < sd; x++)
        {
            for(int y = 0; y < sd; y++)
            {
                if(nodemap[x][y].equals("field"))
                {
                    inspectedFieldCount++;
                    placeSomething(x, y, nodemap);
                    if(GetPlaceableLeft() <= 0)
                        return nodemap;
                }
            }
        }
        if(GetPlaceableLeft() > 0)
        {
            printas("Couldn't place all special fields :(");
        }
        return nodemap;
    }
    
    static String[][] SelectNodes(int[][] noisemap)
    {
        int sd = maxfields-1;
        int ceiling = 10000;
        int foundfields = 0;
        String[][] mapnodes = new String[sd][sd];
        while(foundfields < maxfields)
        {
            label:
            for(int x = 0; x < sd; x++)
            {
                for(int y = 0; y < sd; y++)
                {
                    if(noisemap[x][y] > ceiling)
                    {
                        if(!mapnodes[x][y].equals("field"))
                        {
                            mapnodes[x][y] = "field";
                            foundfields++;
                            if(foundfields >= maxfields)
                                break label;
                        }
                    }
                    else
                    {
                        mapnodes[x][y] = "";
                    }
                }
            }
            ceiling--;
        }
        return mapnodes;
    }

    static String[] AdjacencyMatrixHeader(String[][] nodemap)
    {
        int sd = maxfields - 1;
        int c = 0;
        String[] header = new String[sd+1];
        for (int x = 0; x < sd; x++) {
            for (int y = 0; y < sd; y++) {
                String FID = nodemap[x][y];
                if (!FID.equals(""))
                {
                    printas("found new: " + x + ", " + y + " :: " + FID + " with c: " + c);
                  header[c++] = FID;
                }
            }
        }
        return header;
    }


    private static class Node {
        public String name;
        public Point location;
        //public Node[] neighbours = new Node[0];
        public ArrayList<Node> neighbours = new ArrayList<Node>();
        public Node(String s, Point p){this.name = s; this.location = p;}
        public void AddEdge(Node n)
        {
            neighbours.add(n);
        }

        @Override
        public String toString()
        {
            String ret = "NODE:: " + name + "  neigh: "+neighbours.size();
            return ret;
        }
    }

    static boolean[][] AdjacencyMatrix(String[] header, String[][] nodemap)
    {
        int LEN = header.length;
        //start, create return
        boolean[][] matrix = new boolean[LEN][LEN];

        //create two distinct traces, emerging a web
        int c = 0;
        Node[] primaryWeb = new Node[LEN];
        Node[] secondaryWeb = new Node[LEN];

        //and a bridge for translations
        int[][] bridge = new int[LEN][LEN];

        printas("trace start: info: " + LEN + "  " + nodemap.length);

        for (int i = 0; i < LEN; i++) {
            printas(" at i header " + i + " is: " + header[i]);
        }

        for (int x = 0; x < nodemap.length; x++) {
            for (int y = 0; y < nodemap.length; y++) {
                printnn(nodemap[x][y] + " ");
            }
            printnn("\n");
        }

        for (int x = 0; x < nodemap.length; x++) {
            for (int y = 0; y < nodemap.length; y++) {
                if (!nodemap[x][y].equals(""))
                {
                    bridge[x][y] = c;
                    primaryWeb[c++] = new Node( nodemap[x][y], new Point(x, y));
                    printas("[PR] added new node: " + primaryWeb[c-1].toString() + " at c: " + (c-1) + "  bridge: " + x + "|"+ y + "|"+(c-1));

                }
            }
        }
        c = 0;
        for (int y = 0; y < nodemap.length; y++) {
            for (int x = nodemap.length-1; x >= 0; x--) {
                if (!nodemap[x][y].equals(""))
                {
                    secondaryWeb[c++] = primaryWeb[bridge[x][y]];
                    printas("[SQ] added new node: " + secondaryWeb[c-1].toString() + " at c: " + (c-1));
                    printas("accessing bridge yielded:" + bridge[x][y]);
                }
            }
        }


        //use traces to create neighbourhoods
        Node last = primaryWeb[0];
        for (int i = 1; i < primaryWeb.length; i++) {
            if (last == null)
                printas("last node is null, wtf? info: " +i + " and " +primaryWeb.length);
            Node next = primaryWeb[i];
            last.AddEdge(next);
            last = next;
        }

        last = secondaryWeb[0];
        for (int i = 1; i < secondaryWeb.length; i++) {
            Node next = secondaryWeb[i];
            last.AddEdge(next);
            last = next;
        }

        //create matrix LUT
        HashMap<String, Integer> lut = new HashMap<>();
        for (int i = 0; i < primaryWeb.length; i++) {
            lut.put(primaryWeb[i].name, lut.size());
            printas("put into LUT:" + i + " this: " + lut.get(primaryWeb[i].name) + "  called: " + primaryWeb[i].name);
        }

        // lets follow one of our traces once again to mark neighbouring nodes
        for (int i = 1; i < primaryWeb.length; i++) {
            Node cur = primaryWeb[i];
            int cc = lut.get(cur.name);

            for (int nc = 0; nc < cur.neighbours.size(); nc++) {
                printas("trying NB: " + cur);
                printas("\t nc, " + nc + ": " + cur.neighbours.get(nc));
                int ccn = lut.get(cur.neighbours.get(nc).name);
                matrix[cc][ccn] = true;
                matrix[ccn][cc] = true; //it should be true both ways
            }
        }


        // finishing touches, make sure determinant is null
        for (int i = 0; i < LEN; i++) {
            matrix[i][i] = false;
        }

        return matrix;
    }

    static String[][] UniquifyNodemap(String[][] nodemap)
    {
        int sd = maxfields -1;
        placed_fields.replaceAll((k, v) -> v = 0);

        for(int i = 0; i < sd; i++)
        {
            for(int j = 0; j < sd; j++)
            {
                if(!nodemap[i][j].equals(""))
                {
                    String name = getFieldName(nodemap, i, j);
                    placed_fields.put(nodemap[i][j], placed_fields.get(nodemap[i][j]) + 1);
                    nodemap[i][j] = name;
                }
            }
        }

        return nodemap;
    }
    
    static String ConnectFields(String[] GraphMatrixHeader, boolean[][] GraphMatrix)
    {
        String ret = "";


        for (int x = 0; x < GraphMatrixHeader.length; x++) {
            for (int y = x+1; y < GraphMatrixHeader.length; y++) {

                if (GraphMatrix[x][y])
                {
                    ret+="neighbour " + GraphMatrixHeader[x] + " " + GraphMatrixHeader[y] + "\n";
                }
            }
        }

        return ret;
    }
    
    private static String getFieldName(String[][] nodemap, int i, int j)
    {
        String name = "";
        switch(nodemap[i][j])
        {
            case "lab":
                name = "l" + placed_fields.get("lab");
                break;
            case "field":
                name = "f" + placed_fields.get("field");
                break;
            case "bunker":
                name = "b" + placed_fields.get("bunker");
                break;
            case "ware":
                name = "w" + placed_fields.get("ware");
                break;
            case "bear":
                name = "lb" + placed_fields.get("bear");
                break;
        }
        return name;
    }
    
    static Random r = new Random(useSeed);
    static String[] labCodes = "forget,dance,paralyze,protect".split(",");
    static String[] bunkerEq = "gloves,sack,coat,axe".split(",");
    
    static String CreateLab()
    {
        placed_fields.put("lab", placed_fields.get("lab") + 1);
        return "create l" + placed_fields.get("lab") + " lab\nlab l" + placed_fields.get("lab") + " " + labCodes[r.nextInt(labCodes.length)];
    }
    
    static String CreateField()
    {
        placed_fields.put("field", placed_fields.get("field") + 1);
        return "create f" + placed_fields.get("field") + " field";
    }
    
    static String CreateWare()
    {
        placed_fields.put("ware", placed_fields.get("ware") + 1);
        return "create w" + placed_fields.get("ware") + " ware\nware w" + placed_fields.get("ware") + " " + (15 + r.nextInt(30)) + " " + (15 + r.nextInt(30));
    }
    
    static String CreateBear()
    {
        placed_fields.put("bear", placed_fields.get("bear") + 1);
        return "create lb" + placed_fields.get("bear") + " bear";
    }
    
    static String CreateBunker()
    {
        placed_fields.put("bunker", placed_fields.get("bunker") + 1);
        return "create b" + placed_fields.get("bunker") + " bunker\nbunker b" + placed_fields.get("bunker") + " " + bunkerEq[r.nextInt(bunkerEq.length)];
    }
    
    
    static String CreateFields(String[][] nodemap)
    {
        int sd = maxfields - 1;
        StringBuilder ret = new StringBuilder();
        
        for(int x = 0; x < sd; x++)
        {
            for(int y = 0; y < sd; y++)
            {
                switch(nodemap[x][y])
                {
                    case "lab":
                        ret.append(CreateLab()).append("\n");
                        break;
                    case "field":
                        ret.append(CreateField()).append("\n");
                        break;
                    case "bunker":
                        ret.append(CreateBunker()).append("\n");
                        break;
                    case "ware":
                        ret.append(CreateWare()).append("\n");
                        break;
                    case "bear":
                        ret.append(CreateBear()).append("\n");
                        break;
                }
            }
        }
        
        return ret.toString();
    }
    
    static String GenerateNewMap()
    {
        String[][] arr = NameFields(SelectNodes(NoiseMap()));
        String str = CreateFields(arr);

        arr = UniquifyNodemap(arr);

        String[] GraphMatrixHeader = AdjacencyMatrixHeader(arr);
        boolean[][] GraphMatrix = AdjacencyMatrix(GraphMatrixHeader, arr);

        str += "\n" + ConnectFields(GraphMatrixHeader, GraphMatrix);

        Path path = Paths.get(name + ".map");
        try
        {
            BufferedWriter writer = new BufferedWriter(new FileWriter(path.toString()));
            writer.write(str);
            writer.close();
        }
        catch(IOException e)
        {
            e.printStackTrace();
            printas("Failed to write to file.");
        }
        return path.toAbsolutePath().toString();
    }
    
    public void Swallow(Field what)
    {
        Swallow(what, false);
    }
    
    public void Swallow(Field what, boolean isLab)
    {
        if(isLab)
        {
            field_labs.add((FieldLab) what);
        }
        fields.add(what);
    }
    
    public void SpitViros(int ViroCount, String[] nameViros)
    {
        boolean useVNames = false;
        if(nameViros.length > 0)
        {
            if(nameViros.length < ViroCount)
                printas("Invalid number of names provided to SpitViros, ignoring");
            else
                useVNames = true;
        }
        for(int vir = 0; vir < ViroCount; vir++)
        {
            Virologist viro;
            String VName;
            if(useVNames)
                VName = nameViros[vir];
            else
                VName = "viro" + vir;
            
            viro = (Virologist) EntityManager.CreateEntity("viro", VName);
            
            Field foundField;
            viro.SetField(GetRandomField());
        }
    }
    
    Field GetRandomField()
    {
        int rand = new Random().nextInt(fields.size());
        return fields.get(rand);
    }
    
    /*
        Megszamolja hany tenylegesen megtalalhato genetic code van a palyan
        van egy fields_labs array, azon vegigmesz es megnezed hogy hany kulonbozo codot talalsz
        aztan szivunk egy iqost
     */
    
    public int CountDiffCodes()
    {
        int notFound = 0;
        List<GeneticCode> tempCodes = new ArrayList<>();
        for(FieldLab fieldLab : field_labs)
        {
            if(tempCodes.size() == 0)
            {
                tempCodes.add(fieldLab.getCode());
            }
            else
            {
                for(GeneticCode geneticCode : tempCodes)
                {
                    if(fieldLab.getCode().CompareCodes(geneticCode))
                    {
                        notFound++;
                    }
                }
                if(tempCodes.size() == notFound)
                {
                    tempCodes.add(fieldLab.getCode());
                }
                notFound = 0;
            }
        }
        return tempCodes.size();
    }
    
    public void GenerateMap(String gmInput, String gmSeed, int gmNField, int gmNLabs, int gmNWarehouses,
                            int gmNBunkers, int gmNBearLabs)
    {
        name = gmInput;
        place_these.put("field", gmNField);
        placed_fields.put("field", -1);
        String sseed = gmSeed;
        if(sseed.equals(""))
        {
            Random rand = new Random();
            useSeed = rand.nextInt(1000000);
        }
        else
        {
            useSeed = Long.parseLong(sseed);
        }
        place_these.put("lab", gmNLabs);
        placed_fields.put("lab", -1);
        
        place_these.put("bunker", gmNBunkers);
        placed_fields.put("bunker", -1);
        
        place_these.put("ware", gmNWarehouses);
        placed_fields.put("ware", -1);
        
        place_these.put("bearlab", gmNBearLabs);
        placed_fields.put("bearlab", -1);
        
        maxfields = place_these.values().stream().reduce(0, Integer::sum);
        
        String full = GenerateNewMap();
        ConsoleIO.RunCMD("clear");
        ConsoleIO.RunCMD("load", new String[]{full});
    }
    
    public void GenerateMapDefault(int vc)
    {
        GenerateMap("defaultmap", "", 6*vc, 2*vc, 1*vc, 1*vc, 0*vc);
        printas("Generated default map, multiplying size by virocount");
    }
    
    public void GenerateTestMap(int vc)
    {
        ConsoleIO.RunCMD("load", new String[]{"devmap.map"});
    }
}
